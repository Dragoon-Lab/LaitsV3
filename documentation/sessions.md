# Sessions #

First, some definitions. We distinguish between the LMS and the tutor:

* __tutor__ is the Javascript code for Dragoon. It is invoked
via the URL `index.html`. On startup, the URL includes name-value pairs
of the [major mode](major-modes.md), user name, section, 
problem name, and (optionally) the problem author. 
*  __LMS__ or Learning Management System refers to the "outer loop" that
invokes the tutor system for a particular user, group, problem, author. 
It could be a full LMS like Moodle, or a simple web page like  `www/login.html`.

For the tutor, we distinguish between two usage modes:

* __student__ which includes [major modes](major-modes.md) COACHED, STUDENT, 
and TEST. In this usage mode, the user modifies 
the "student graph" which contains the model they are constructing.
The tutor compares the student graph with the "solution graph" that is
associated with that problem.
* __author__ which corresponds to the AUTHOR major mode. In this mode,
the user modifies only a problem's "solution graph."

Also, there are two classes of solution graphs:

* __published__ or __static__ problems provided by the tutoring system. 
These are stored as files in `www/problems/` and are uniquely identified by
their name. They are available to all users
(no section restrictions), and one can assume that the LMS has a list of
these problems. Students select published problems via the LMS. 
If the tutor is being run locally, these problems are 
stored along side the java code (this doesn't exist yet).
* __custom__ or __dynamic__ problems are authored
by users. 

## Session ID ##

Associated with each java/javascript instance of Dragoon will be a unique session identifier.  In the javascript version, a page reload will generate a new session ID.  In the java version, each running of `Laits.jar` will generate a new session ID.  Opening more than one problem (or renaming a problem) *may* occur during a given session.

The format for the session ID variable `sessionId` will be a string of length 50.
It is convenient to generate `sessionId` by applying a hash function
to the user name and section name and adding a timestamp.  An example
javascript implementation can be found in Andes:  see the function
`FNV1aHash` and the code that follows it in the file
[`web-UI/andes/startup.js`](https://github.com/bvds/andes/blob/master/web-UI/andes/startup.js).
In Andes, we found it convenient to include the session ID as an HTTP
header when communicating between client and server.

## Database tables ##

**`session`**: this table lists the sessions.

*	`session_id` – primary key for this table; it is generated by the client.
*	`mode` – Value is a [major mode](major-modes.md)
*	`time` – this will be the server time. This can be set using `CURRENT_TIMESTAMP` in mySQL.
*	`user` – user name (string)
*	`section` – section name (string).
*   `problem` - problem name (string).  May be NULL if `mode` is `author`.
*	 `author` - For custom problems (string).  Otherwise it will be NULL.

This table similar to the table `PROBLEM_ATTEMPT` in Andes; see
[create_PROBLEM_ATTEMPT.sql](https://github.com/bvds/andes/blob/master/LogProcessing/database/create_PROBLEM_ATTEMPT.sql).
The Andes table can be used to see how the `session` table should be
formatted.  Note that the column names of this table correspond to the [list of variable names](sessions.md). 

**`autosave_table`**:  Stored student work on a problem. This table
has columns for the session ID, time stamp, the student problem and
solution (in Java, this is in XML and in Javascript the format is JSON). 
This table is accessed via the script `postvar.php`.

**`solutions`** table stores solution graphs for custom problems.
This table has columns for author name, section, problem name, a "share" bit
(default zero), a "deleted" bit (default zero), a timestamp and the 
solution graph (XML for Java version and JSON for Javascript version) (text). 
The primary key for the table should consist of: 
 section, problem name, and author name. It is important that section is
listed first.

The share bit determines whether a custom problem can be viewed --
in either author or student mode -- by other members of a section. 
If `false`, then only the author may view the problem. If `true`, then
all students in a section may view that problem. Custom problems cannot
be viewed by users outside of a section.

## Variable names identifying users and problems ##

There are two issues: we might want to specify short
names for http requests and we may in the future slowly switch over to
using numerical IDs for some quantities so that we can abstract away 
from user, section, and problem names.
(See the way things are done in phpBB for an example.)

Here is a starting list.  Note that some items should not have an id.
The categories are *name*, *short name*, *id*, *short id*:

- user, u userId, uid
- section, s, sectionId, sid
- problem, p, problemId, pid
- author, au (for custom problems; this is the original author's
  user name)
- newProblem, np, newProblemId, npid
- solutionXML, sx  (for solution text)
- action, ac
- mode, m (value is a [major mode](major-modes.md))
- sessionId, x (see [Logging Format](logs-structure.md))
- forumURL, f
- location (what is this?)
- logText (for msg)
- logger
- level
- share

For mysql database table column names, we will replace camelCase with
underscores: sessionId -> session_id, userId -> user_id, *et cetera*.
Quantities in  categories *name* and *short name* are strings, while
*id* and *short id* represent integers.

This list is not written in stone:  please correct/change/improve as you 
see fit.  The idea is not to change this all at once, especially in the 
java code, since we are switching over to Javascript.  However, any 
Javascript should be consistent with this list.


## Access to the custom problem solution graphs ##

In the Java version, the state associated with a problem solution
has two forms:  an internal form and an exported form.  The java
client cannot read the exported form in author mode.
The internal form is stored in the table `unsolutions` and the 
exported form is stored in the table `solutions`.  In the Javascript
version, there will be only one form, which will be stored in
the `solutions` table.

To retrieve custom problems, the script `task_fetcher.php`
looks for a matching problem in the `solutions` table, then attempts
to find a matching published problem. 
Calls to `task_fetcher.php` use the GET method and must include a problem name, and may
include an author name and section name. Author name and section are
mandatory for a match to a custom problem.

The script `save_solution.php` is invoked with POST and must include problem name,
author name, section name, and the solution graph xml (text). It may also
set the "share" bit. It *may* overwrite any existing entry with matching author,
section, and problem.

If the user is in author mode, `save_solution.php` is called at all instances
where the `postvar.php` is invoked in student mode.


## Custom Problem Selection ##

The server script `available_problems.php` retrieves all problems available
to the student in the form of author, problem name pairs 
(in xml or json format). It is called using the GET method with the user 
name and section supplied.

Either the LMS or the tutor itself can request this list.
Note that the response includes a list of all problems that the
user has previously worked on, either as a student or as an author.

In the LMS, the student may be supplied with a list of 
available custom problems via a call to `available_problems.php`.
The student may choose one of
the existing problems, or, if they are in author mode, they
may choose a new problem name.

## Student graph Selection ##

The server script `student_graphs.php` retrieves all matching student solution graphs 
available in the `autosave_table`. 
It is called using the GET method with arguments:  section, problem, and (optionally) author.
It returns list of user, author pairs (in json or xml format). 

## Student Mode ##

In this mode the user only modifies the student graph. This mode
is pretty restrictive: the student may not rename a problem or merge other
solutions with their solution or share their solution with other students.

If the student wants to "start over" on a problem, they may erase
all their current work on that problem. For convenience, we may provide
a button in the tutor for this purpose. For instance, the tutor could prompt
the student when a problem is opened.

## Author Mode ##

In author mode, the LMS *may* choose to display only problems that the user
has themselves authored, along with the ability to create a new
problem name. The author can choose to share his problem with other
students to solve as a student, test, or coached mode problem.  In 
Java this is the "Export" step, in Javascript this is done by enabling
the "share" option.  The author needs to be able to define a node as 
a "first node" for the coached mode target node strategy to work;
these could be set at export or by a toggle in the node editor.

In author mode, the tutor provides a menu where a student may
**merge** an existing solution with their solution. The solutions
are provided by the `available_problems.php`. Also, the tutor UI
has a switch that allows the user to change the share bit.

The mechanism for a user to "fork" an existing problem that 
they have authored is the following:  In the LMS, the student chooses a 
new problem name. This opens a new empty problem. 
They then use the **merge** menu to load the existing problem of interest. 
This creates a copy of
an existing problem with a new name. If student *A* chooses to open a
problem authored by student *B*, then that creates an identical problem
(with the same name) owned by student *A*.

The tutor will also have a "save as" button which allows the
author to rename the problem they are working on. This functionality
is not strictly needed but it fits better with the behavior of
many desktop computer applications and will probably be more
intuitive for most users.

Finally, the tutor needs a method for allowing the author to
create the "predefined" nodes for a problem. This would be some
sort of switch in the UI?

Since users of the Forum landing page often work in groups, it has been modified to allow multiple authors to author the same problem.  When a problem is created, its original author is assigned in the "author groups" table.  If another student attempts to enter that problem to author it, they are added to "author groups" as an additional author.  The Forum page will pass the original author's name to the PHP, allowing the second person access to the problem. 
## Open and Managed access modes ##

[Some notes from Kurt](Dragoon_model_storage_use_cases_13_08_12.docx) on 
session management. In Kurt's design, all custom problem solutions
are stored on the student's computer. The only *functionality* in
Kurt's design that is missing here is the case where a student needs 
to share their solution to a problem solved in student mode 
("Open access mode," first use case).

## Read-only access for instructors and authors ##

We have the use cases:

* Instructors need to be able to view solution graphs for all problems in
a section, not just ones marked "shared".
* Instructors need to be able to view student graphs for all members of the section.
* Authors need to be able to view student graphs associated with all problems
that they have authored.

This is accomplished in the tutor using the `student_graphs.php` script.
We need to decide on the behavior of the tutor for this:

* Does it open a separate window or is it shown in the main window?
* Is this available in student mode, author mode or both?
* What happens to any currently loaded student graph for this problem?
* Is there some mechanism for closing the problem?
* If it is "Read-only" does that mean that student graph is frozen,
or that changes are not logged on the server?
* What, precisely, gets logged?

In all cases, the author/instructor must be able to open the
discussion tab for all nodes and add to the discussions.
